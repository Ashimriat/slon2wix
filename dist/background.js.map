{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/background/index.js","webpack:///./src/constants.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAuE;;AAEvE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,uDAAY;AACtC;AACA,iBAAiB,uDAAY;AAC7B,EAAE;AACF,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA,kCAAkC,iBAAiB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,CAAC;;;AAGD;AACA;AACA;AACA,qCAAqC,qBAAqB;AAC1D,0CAA0C,OAAO,mDAAQ,mBAAmB,IAAI,OAAO;AACvF;AACA;AACA,MAAM;AACN,gCAAgC;AAChC;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,qBAAqB,+BAA+B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA4B,EAAE,uDAAY,iDAAiD;AAC3F;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa,+CAAI,OAAO;AACxC,MAAM;AACN;AACA;AACA;AACA;AACA,+CAA+C,0BAA0B;AACzE;AACA,IAAI;AACJ;AACA;AACA;AACA,gBAAgB,aAAa,+CAAI,MAAM;AACvC,MAAM;AACN;AACA;AACA;AACA;AACA,+CAA+C,0BAA0B;AACzE;AACA;AACA;AACA,EAAE;AACF,CAAC;;AAED;AACA;AACA,EAAE;AACF,CAAC;;;;AAID;AACA,QAAQ,MAAM;AACd,eAAe,+CAAI;AACnB;AACA;AACA,EAAE,oBAAoB,+CAAI;;AAE1B;AACA,CAAC;;;;;;;AAOD;AACA;AACA;AACA,4BAA4B;AAC5B,gBAAgB;AAChB;AACA;AACA,EAAE;AACF;AACA,yBAAyB,gCAAgC,EAAE;AAC3D;AACA,6BAA6B,wCAAwC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA,4BAA4B,6BAA6B;AACzD,6BAA6B,oCAAoC;AACjE,CAAC;;AAED,mBAAmB,oCAAoC;AACvD;AACA;AACA,sCAAsC,oBAAoB;;AAE1D,EAAE;AACF,CAAC;AACD;;;;;;;;;;;;;ACxNA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAO;AACP;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEO;;AAEA;AACP;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEO;;AAEA;;AAEA;AACP;AACA;AACA;AACA;AACA;AACA;;AAEO;;AAEA;AACP;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEO;;AAEA;;AAEA","file":"background.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/background/index.js\");\n","import { HOST, STORAGE_KEYS, PORT_NAME, MESSAGES } from '../constants';\r\n\r\nconst PAGE_ACTION_ALLOWANCE = {\r\n\tslon: true,\r\n\twix: true\r\n};\r\n\r\nconst PAGE_CONTENT_SCRIPT_ALLOWANCE = {\r\n\tslon: false,\r\n\twix: false\r\n};\r\n\r\nlet fileData,\r\n\ttmpItem,\r\n\ttmpCategoryIndex = 0,\r\n\ttmpItemIndex = 0,\r\n\tUSED_TAB_ID,\r\n\titemInfoObtainingPromise;\r\n\r\nconst getLastModifyDate = async () => await new Promise(resolve => {\r\n\tchrome.storage.sync.get([STORAGE_KEYS.LAST_MODIFIED], result => {\r\n\t\tconsole.log(\"DATE RESULT\", result);\r\n\t\tresolve(result[STORAGE_KEYS.LAST_MODIFIED] || '');\r\n\t});\r\n});\r\nconst trackInfoObtainingPromise = async () => await new Promise(resolve => {\r\n\tlet timerId;\r\n\tconst tracker = () => {\r\n\t\tif (!itemInfoObtainingPromise) {\r\n\t\t\ttimerId = setTimeout(tracker, 500);\r\n\t\t} else {\r\n\t\t\tclearTimeout(timerId);\r\n\t\t\tresolve();\r\n\t\t}\r\n\t};\r\n\ttracker();\r\n});\r\n\r\nconst obtainFileInfo = async () => {\r\n\tconst response = await fetch ('http://localhost:3000/getInfo', {\r\n\t\tmethod: 'POST',\r\n\t\tbody: await getLastModifyDate(),\r\n\t\theaders: {\r\n\t\t\t'Accept':'application/json',\r\n\t\t}\r\n\t});\r\n\treturn await response.json();\r\n};\r\n\r\nconst getItemInfo = async (item) => await new Promise(resolve => {\r\n\ttmpItem = item;\r\n\tchrome.tabs.update(USED_TAB_ID, { url: item.link }, async tab => {\r\n\t\tPAGE_CONTENT_SCRIPT_ALLOWANCE.slon = true;\r\n\t\tawait trackInfoObtainingPromise();\r\n\t\tawait itemInfoObtainingPromise;\r\n\t\titemInfoObtainingPromise = null;\r\n\t\ttmpItemIndex++;\r\n\t\t// если дошли до последнего итема в категории\r\n\t\tif (tmpItemIndex === fileData[tmpCategoryIndex].items.length) {\r\n\t\t\ttmpItemIndex = 0;\r\n\t\t\ttmpCategoryIndex++;\r\n\t\t\t// если это была последняя категория - все закончилось\r\n\t\t\tif (tmpCategoryIndex === fileData.length) {\r\n\t\t\t\tconsole.log(\"LAST ITEM OF LAST CATEGORY\");\r\n\t\t\t\tconsole.log(fileData);\r\n\t\t\t\ttmpCategoryIndex = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t\tresolve();\r\n\t});\r\n});\r\n\r\n\r\nconst obtainInfoTabUpdatedListener = (tabId, tabInfo) => {\r\n\tif (tabId === USED_TAB_ID && tabInfo.status === 'complete' && PAGE_CONTENT_SCRIPT_ALLOWANCE.slon) {\r\n\t\titemInfoObtainingPromise = new Promise(resolve => {\r\n\t\t\tchrome.tabs.executeScript(tabId, { file: 'content.js' }, () => {\r\n\t\t\t\tchrome.tabs.sendMessage(USED_TAB_ID, { type: MESSAGES.OBTAIN_ITEM_INFO }, ({ info }) => {\r\n\t\t\t\t\tif (info === 'error') {\r\n\t\t\t\t\t\tfileData[tmpCategoryIndex].items.splice(tmpItemIndex, 1);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttmpItem = Object.assign({}, tmpItem, info);\r\n\t\t\t\t\t\tdelete tmpItem.link;\r\n\t\t\t\t\t\tfileData[tmpCategoryIndex].items[tmpItemIndex] = tmpItem;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tresolve();\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t})\r\n\t}\r\n};\r\n\r\nconst loadInfoTabUpdatedListener = (tabId, tabInfo) => {\r\n\tif (tabInfo.status === 'complete') {\r\n\t\t// your code ...\r\n\t}\r\n};\r\n\r\n\r\nconst startInfoParsing = () => {\r\n\t// создаем новую табу, в которой будут происходить все переходы\r\n\tchrome.tabs.create({ active: false, pinned: false }, async tab => {\r\n\t\t// запоминаем ее id\r\n\t\tUSED_TAB_ID = tab.id;\r\n\t\t// добавляем обработчик, который будет делать магию после загрузки страницы в табе\r\n\t\tchrome.tabs.onUpdated.addListener(obtainInfoTabUpdatedListener);\r\n\t\t// перебираем категории\r\n\t\tfor (let category of fileData) {\r\n\t\t\t// перебираем итемы\r\n\t\t\tfor (let item of category.items) {\r\n\t\t\t\tawait getItemInfo(item);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n};\r\n\r\nconst obtainProductsInfo = async () => {\r\n\tconst productsData = await obtainFileInfo();\r\n\tif (productsData.status === 'new') {\r\n\t\tfileData = productsData.info;\r\n\t\tconsole.log(fileData);\r\n\t\tchrome.storage.local.set({ [STORAGE_KEYS.LAST_MODIFIED]: String(productsData.timeStamp) });\r\n\t\tstartInfoParsing();\r\n\t} else {\r\n\t\r\n\t}\r\n};\r\n\r\nchrome.runtime.onInstalled.addListener(() => {\r\n\t// Заменяем все правила\r\n\tchrome.declarativeContent.onPageChanged.removeRules(undefined, () => {\r\n\t\t// Новыми правилами\r\n\t\tchrome.declarativeContent.onPageChanged.addRules([\r\n\t\t\t{\r\n\t\t\t\tconditions: [\r\n\t\t\t\t\tnew chrome.declarativeContent.PageStateMatcher({\r\n\t\t\t\t\t\tpageUrl: { hostEquals: HOST.SLON },\r\n\t\t\t\t\t})\r\n\t\t\t\t],\r\n\t\t\t\t// And shows the extension's page action.\r\n\t\t\t\tactions: [\r\n\t\t\t\t\tnew chrome.declarativeContent.ShowPageAction(),\r\n\t\t\t\t\t// new chrome.declarativeContent.SetIcon({ path: 'assets/icon.png' })\r\n\t\t\t\t]\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\tconditions: [\r\n\t\t\t\t\tnew chrome.declarativeContent.PageStateMatcher({\r\n\t\t\t\t\t\tpageUrl: { hostEquals: HOST.WIX },\r\n\t\t\t\t\t})\r\n\t\t\t\t],\r\n\t\t\t\t// And shows the extension's page action.\r\n\t\t\t\tactions: [\r\n\t\t\t\t\tnew chrome.declarativeContent.ShowPageAction(),\r\n\t\t\t\t\t// new chrome.declarativeContent.SetIcon({ path: 'assets/icon.png' })\r\n\t\t\t\t]\r\n\t\t\t}\r\n\t\t]);\r\n\t});\r\n});\r\n\r\nchrome.tabs.onSelectionChanged.addListener(tabId => {\r\n\tchrome.tabs.get(tabId, tab => {\r\n\t});\r\n});\r\n\r\n\r\n\r\nchrome.pageAction.onClicked.addListener(tab => {\r\n\tconst { url } = tab;\r\n\tif (url.match(HOST.SLON)) {\r\n\t\tchrome.pageAction.hide(tab.id);\r\n\t\tobtainProductsInfo();\r\n\t} else if (url.match(HOST.WIX)) {\r\n\t\r\n\t}\r\n});\r\n\r\n\r\n\r\n\r\n\r\n\r\n/*\r\nchrome.pageAction.onClicked.addListener(tab => {\r\n\tvar clicks = tab_clicks[tab.id] || 0;\r\n\tchrome.pageAction.setIcon({path: \"icon\" + (clicks + 1) + \".png\",\r\n\t\ttabId: tab.id});\r\n\tif (clicks % 2) {\r\n\t\tchrome.pageAction.show(tab.id);\r\n\t} else {\r\n\t\tchrome.pageAction.hide(tab.id);\r\n\t\tsetTimeout(function() { chrome.pageAction.show(tab.id); }, 200);\r\n\t}\r\n\tchrome.pageAction.setTitle({title: \"click:\" + clicks, tabId: tab.id});\r\n\t// We only have 2 icons, but cycle through 3 icons to test the\r\n\t// out-of-bounds index bug.\r\n\tclicks++;\r\n\tif (clicks > 3)\r\n\t\tclicks = 0;\r\n\ttab_clicks[tab.id] = clicks;\r\n});\r\n\r\n\r\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\r\n\tchrome.pageAction.setIcon({ path: '../assets/slon.png' });\r\n\tchrome.pageAction.setTitle({ title: 'Собрать данные о товарах' });\r\n});\r\n\r\nchrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {\r\n\tlastTabId = tabs[0].id;\r\n\tchrome.pageAction.show(lastTabId);\r\n\tchrome.tabs.sendMessage(tabs[0].id, { greeting: \"hello\" }, (response) => {\r\n\t\r\n\t});\r\n});\r\n*/\r\n","export const HOST = {\r\n\tSLON: 'slon-tea.ru',\r\n\tWIX: 'wix.com'\r\n};\r\n\r\nexport const STORAGE_KEYS = {\r\n\tDATA: 'slon_data',\r\n\tLAST_MODIFIED: 'slon_last_modified'\r\n};\r\n\r\nexport const PORT_NAME = 'SLON_2_WIX';\r\n\r\nexport const MESSAGES = {\r\n\tOBTAIN_ITEM_INFO: 'SLON.OBTAIN_ITEM_INFO',\r\n\tGOT_ITEM_INFO: 'SLON.GOT_ITEM_INFO'\r\n};\r\n\r\nexport const SLON_ROUTES = {\r\n\tREGEXP: /\\/(tea|kofe|posuda_i_aksessuari|sladosti)/,\r\n\tTEA: '/tea',\r\n\tCOFFEE: '/kofe',\r\n\tTABLEWARE: '/posuda_i_aksessuari',\r\n\tSWEETS: '/sladosti'\r\n};\r\n\r\nexport const SERVER_ROUTES = {\r\n\tPARSE_INFO_FILE: '/getInfo'\r\n};\r\n\r\nexport const CONTENT_TABLE_SELECTOR = '#product-list > .row > .col.s12.m8.l9 > ul.row';\r\n\r\nexport const ITEM_SELECTOR = 'li > div > a';\r\n\r\nexport const COFFEE_COOK_CATEGORIES = {\r\n\t'Эспрессо': 'espresso',\r\n\t'Турка': 'turk',\r\n\t'Фильтр': 'filter',\r\n\t'Френч-пресс': 'frenchPress',\r\n\t'Чашка': 'cup'\r\n};\r\n\r\nexport const COFFEE_COOK_CATEGORIES_REGEXP = /(Эспрессо|Турка|Фильтр|Френч-пресс|Чашка)/;\r\n\r\nexport const ITEMS_TYPES_SELECTORS = {\r\n\timage: '#product-image',\r\n\tdescription: '#desc_pr',\r\n\tvendorCode: '.bas_f_i.skusi_a',\r\n\terror404: '.img_slon',\r\n\tname: '#prod_title'\r\n};\r\n\r\nexport const SECTIONS_NAMES = {\r\n\tCOMMON: [ 'Описание', 'Вкус'],\r\n\tTEA: [ 'Как заваривать' ],\r\n};\r\n\r\nexport const COFFEE_INFO_CATEGORIES = {\r\n\t'Способ обработки кофейных зерен': 'processing',\r\n\t'Степень обжарки': 'roast',\r\n\t'Кислотность напитка по шкале от 0 до 5': 'toxicity'\r\n};\r\n\r\nexport const COFFEE_INFO_CATEGORIES_REGEXP = /(Способ обработки кофейных зерен|Степень обжарки|Кислотность напитка по шкале от 0 до 5)/;\r\n\r\nexport const SWEETS_INFO_CATEGORIES_REGEXP = /(Состав|Условия хранения)/;\r\n\r\nexport const TABLEWARE_INFO_CATEGORIES_REGEXP = /^Объ(е|ё)м:/;\r\n"],"sourceRoot":""}